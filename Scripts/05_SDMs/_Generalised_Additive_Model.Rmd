---
title: "Generalised Additive Model"
author: "Denisse Fierro Arcos"
date: "2023-09-22"
output: 
  github_document:
    toc: true
    html_preview: false
---

# Generalised Additive Model (GAM)

GAMs are commonly used in species distribution modelling because of their flexibility. GAMs use smoothing functions to capture non-linear relationships between the dependent variable and the predictors (i.e., independent variables).

In this project, we will use GAMs as one of the models to be considered in our Species Distribution Model ensemble to estimate the distribution of crabeater seals in the recent past.  
  
## Loading libraries

```{r, message=F, warning=FALSE}
library(tidyverse)
library(mgcv)
source("useful_functions.R")
```


## Setting up

Selecting an output folder for GAM results exists and getting a list of data files.  
  
```{r}
#Location of folder for outputs
out_folder <- "../../SDM_outputs/GAM"
#If folder does not exist, create one
if(!dir.exists(out_folder)){
  dir.create(out_folder, recursive = T)
}

#Get path to files containing data
file_list <- list.files("../../Environmental_Data/", pattern = "Indian", full.names = T)

```
  
## Loading environmental data from ACCESS-OM2-01 and setting up variables

We will use the datasets created in the notebook `02_Merging_background_presence_data.Rmd` located within the `Scripts/05_SDMs` folder. These datasets include the crabeater seal observations, background points, and environmental data.  
  
We will also define categorical and continuous explanatory variables.  
  
### Environmental variables matching observations 
First, we will look only at the variables with no multicollinearity. This means that sea surface temperature (`SST`) is excluded even though this variable is available in the observational dataset.  
  
The variable `month` will be included as an ordinal factor in our analysis.  
  
```{r}
#Loading data
mod_match_obs <- read_csv(str_subset(file_list, "match")) %>% 
  #Setting month as factor and ordered factor
  mutate(month = factor(month),
         month_ordered = factor(month, ordered = T))

#List of categorical variables
cat_vars <- c("month", "month_ordered")

#List of covariates
covars <- str_subset(names(mod_match_obs), "presence|_ocean", negate = T)
```
  
### Building GAM formula
We will run an initial GAM using all available covariates. Sea ice related variables will be fitted individually to each `month` as we expect sea ice to vary in extent between November and December because sea ice should be retreating during this time.  
  
```{r}
# Most complex model
full_model <- presence ~ month + s(year) + s(bottom_slope_deg) + s(dist_shelf_km) + s(dist_coast_km) + s(depth_m) + s(SIC) + s(SIC, by = month_ordered) + s(lt_pack_ice) + s(lt_pack_ice, by = month_ordered) + s(dist_ice_edge_km) + s(dist_ice_edge_km, by = month_ordered)
```
    
### Splitting data into testing and training
The `prep_data` function in the `useful_functions` script will be used to split our data and to apply all necessary transformations.  
  
```{r}
#Getting training data
mod_match_obs_split <- prep_data(mod_match_obs, cat_vars)

#Selecting model data
model_data <- mod_match_obs_split$baked_train %>%
  select(all_of(covars) | "presence")
```
  
### Calculating weights for GAM
Background data (`presence` == `0`) will be down-weighted because they do not truly represent absences. The down-weighting applied represents the proportion of presence to background points. In this way, the sum of the weighted background points will be the same as the total of presences.  

Infinitely weighted - 1e3^(1-y) - `model_data %>% mutate(weight = 1e3^(1-presence)) %>% pull(weight)`
  
```{r}
#Calculating downweights
weight <- model_data %>% 
  count(presence) %>% 
  pivot_wider(names_from = presence, values_from = n) %>% 
  mutate(weight = `1`/`0`) %>% 
  pull(weight)

#Storing weights in new variable
weights <- model_data %>% 
  mutate(weight = case_when(presence == 0 ~ weight,
                              T ~ presence)) %>% 
  pull(weight)
#Remove variable not needed
rm(weight)
```
  
### Modelling
We will now run the GAM using all covariates available and we will downweight background points so they have the same effect as all presences.  
  
```{r}
#Full model
full_model_gam <- gam(formula = as.formula(full_model),
    data = model_data,
    family = binomial(link = "cloglog"),
    weights = weights,
    method = "REML", select = T)

#Print summary
summary(full_model_gam)
```
  
Removing variables with effects reduced to near zero (`edf` < 0.001) and that are non-significant: `year`, `bottom_slope_deg` (seafloor slope), `dist_coast_km` (distance to coast in km). After evaluating the diagnostic plots from the model above, the `dist_shelf_km` (distance to continental shelf in km) will also be removed because its effect is negligible.
    
```{r}
#Defining new formula without non-significant covariates
significant_only <-  presence ~ month + s(dist_shelf_km) + s(depth_m) + s(SIC) + s(SIC, by = month_ordered) + s(lt_pack_ice) + s(lt_pack_ice, by = month_ordered) + s(dist_ice_edge_km) + s(dist_ice_edge_km, by = month_ordered)

#Applying new formula
significant_only_gam <- gam(formula = as.formula(significant_only),
    data = model_data,
    family = binomial(link = "cloglog"),
    weights = weights,
    method = "REML", select = T)

summary(significant_only_gam)
```
  
### Comparing models
The Akaike's Information Criterion (AIC) will be calculated to assess model performance. We will also check the $r^{2}$ values for both models.    

```{r}
#Putting everything in a data frame
sum_gam <- data.frame(model = c("full_model", "significant_only"),
                      AIC = c(AIC(full_model_gam), AIC(significant_only_gam)),
                      rsq = c(summary(full_model_gam)$r.sq, summary(significant_only_gam)$r.sq))
#Checking results
sum_gam
```
  
These models performed almost the same, so we will keep the most parsimonious model (i.e., `significant_only`), which has a slightly lower AIC and slightly higher $r^{2}$.  We will include `SST` to this model and check the effect of `SST` on model performance. The smoothing for this variable will vary by month as we have done with sea ice related variables.  
  
```{r}
significant_only_SST <-  presence ~ month + s(dist_shelf_km) + s(depth_m) + s(SIC) + s(SIC, by = month_ordered) + s(lt_pack_ice) + s(lt_pack_ice, by = month_ordered) + s(dist_ice_edge_km) + s(dist_ice_edge_km, by = month_ordered) + s(SST_degC) + s(SST_degC, by = month_ordered)

#Applying new formula
significant_only_SST_gam <- gam(formula = as.formula(significant_only_SST),
    data = model_data,
    family = binomial(link = "cloglog"),
    weights = weights,
    method = "REML", select = T)

#Check results
summary(significant_only_SST_gam)
```
  
The model that includes `SST` explains almost 9\% of variability in the data, which is higher than the previous models. We can see that now sea ice concentration (`SIC`) has become insignificant, and this is likely because of its high correlation to `SST`. We will keep the `SIC` by month because it is highly significant. We will remove this variable, together with distance to the shelf (`dist_shelf_km`) because its effect is near zero (`edf` < 0.001) and it is also non-significant.  
  
```{r}
significant_only_no_SIC <-  presence ~ month + s(depth_m) + s(SIC, by = month_ordered) + s(lt_pack_ice) + s(lt_pack_ice, by = month_ordered) + s(dist_ice_edge_km) + s(dist_ice_edge_km, by = month_ordered) + s(SST_degC) + s(SST_degC, by = month_ordered)

#Applying new formula
significant_only_no_SIC_gam <- gam(formula = as.formula(significant_only_no_SIC),
    data = model_data,
    family = binomial(link = "cloglog"),
    weights = weights,
    method = "REML", select = T)

#Check results
summary(significant_only_no_SIC_gam)
```
  
The performance of this reduced model is basically the same as the previous one. We will calculate AIC and extract $r^{2}$ values and add them to our summary table.  
  
```{r}
#Adding results to summary table
sum_gam <- data.frame(model = c("significant_only_SST", "significant_only_no_SIC"),
                      AIC = c(AIC(significant_only_SST_gam), AIC(significant_only_no_SIC_gam)),
                      rsq = c(summary(significant_only_SST_gam)$r.sq, summary(significant_only_no_SIC_gam)$r.sq)) %>% 
  bind_rows(sum_gam, .) %>% 
  #Arrange in increasing order by AIC
  arrange(AIC)

#Checking results
sum_gam
```
  
We can see that the best performing model based on AIC is the last one we tested, which includes `SST`, excludes `SIC`, but keeps `SIC` by month (`significant_only_SST` in table above). We can check if the performance of this model differs significantly from the model that did not include `SST` (`significant_only` in table above). To do this, we will performance an ANOVA test.  
  
```{r}
anova(significant_only_gam, significant_only_no_SIC_gam, test = "Chisq")
```
  
We can see these models differ significantly, so we will use the `significant_only_no_SIC` to predict crabeater distribution. We will now use the full range of covariates available in the ACCESS-OM2-01 model. We will test if the inclusion of additional environmental variables improve predictive ability.  
  
```{r}

```
  




```{r}
test_pred <- c(predict.gam(mod_gam2, newdata = mod_match_obs_split$baked_test, type = "response")) 

test_pred <- mod_match_obs_split$baked_test %>% 
  select(xt_ocean, yt_ocean, presence) %>% 
  mutate(pred = test_pred)
```





```{r}
test_pred %>% 
  filter(presence == 1) %>% 
  ggplot(aes(xt_ocean, yt_ocean))+
  geom_point()
```

```{r}
test_pred %>% 
  filter(pred >= 0.5) %>% 
  ggplot(aes(xt_ocean, yt_ocean))+
  geom_point(aes(color = pred))+
  scale_color_viridis_c(direction =  -1)
```


```{r}
test_pred %>% 
  filter(pred < 0.5) %>% 
  ggplot(aes(xt_ocean, yt_ocean))+
  geom_point(aes(color = pred))+
  scale_color_viridis_c(direction =  -1)
```




```{r}
#Selecting variables available as 
covars_match_obs <- str_subset(names(mod_match_obs), "presence|_ocean", negate = T)
```



```{r}
gam_mod <- gen_additive_mod(mode = "regression", select_features = T,
                            adjust_deg_free = 5) %>%
  set_engine("mgcv", family = binomial(link = "cloglog"), method = "REML")

gam_fit <- gam_mod %>% 
  fit(as.formula(gam_forms[1]), data = model_data)

tidy(gam_fit)
```


```{r}
gam_mod <- gen_additive_mod(mode = "regression", select_features = T) %>%#,
                            # adjust_deg_free = 1) %>% 
  set_engine("mgcv", family = binomial(link = "cloglog"), method = "REML")

gam_fit <- gam_mod %>% 
  fit(as.formula(gam_forms[1]), data = model_data)

tidy(gam_fit)
```


  
  
```{r}
library(parsnip)
library(tune)
library(dials)

#Creating recipe - steps to be followed when pre-processing data
recipe_bg <- recipe(presence ~ ., mod_match_obs_split$train) %>%
  #Coordinates (xt_ocean and yt_ocean) are not pre-processed
  add_role(xt_ocean, yt_ocean, new_role = "no_prepro") %>% 
  add_role(cat_vars, new_role = "no_prepro") %>% 
  #Scaled and center all predictors - exclude coordinates
  step_center(all_predictors(), -has_role("no_prepro")) %>% 
  step_scale(all_predictors(), -has_role("no_prepro")) %>% 
  prep()

prepro <- recipe_bg %>% 
  bake(mod_match_obs_split$train)

test_prep <- recipe_bg %>% 
  bake(mod_match_obs_split$test)

folds <- vfold_cv(prepro, v = 5)

gam_params <- parameters(adjust_deg_free())

# cv <- trainControl(method = "repeatedcv", number = 10, repeats = 5)
# hyper_grid <- expand.grid(df = 2:5)#formula = gam_forms$gam_forms)
gam_grid <- grid_max_entropy(gam_params, size = 5)

gam <- gen_additive_mod(mode = "regression", 
                        adjust_deg_free = tune()) %>% 
  set_engine("mgcv") 

gam_wf <- workflow() %>% 
  add_variables(outcomes = presence, predictors = env_non_cat) %>% 
  add_model(gam, formula = as.formula(gam_forms[1,])) #%>% 
  # add_recipe(formula = as.formula(gam_forms[1,]))
  # fit(as.formula(gam_forms[1,]), data = mod_match_obs_split$train)

spline_gam <- tune_grid(model = gam, gam_wf,
                        resamples = folds, 
                        grid = gam_grid, metrics = metric_set(mae, rmse, rsq))

show_best(spline_gam, metric = "rmse") 

params <- select_best(spline_gam, metric = "rmse") %>% 
  select(adjust_deg_free)#, maximize = F)

gam_end <- gam %>% 
  finalize_model(parameters = params)

gam_end %>% 
  fit(formula = as.formula(gam_forms[1,]),
      data = prepro) %>% 
  predict(new_data = test_prep) %>% 
  bind_cols(mod_match_obs_split$test) %>% View()

# gam_fit <- train(recipe_bg, data = mod_match_obs_split$train, 
#                  method = "gam", trControl = cv, tuneGrid = hyper_grid,
#                  metric = "RMSE")
```

  
## Loading environmental data
  
```{r}
#Env data to predict
evaluation <- read_csv("../../Environmental_Data/ACCESS-OM2-01/All_values_ACCESS-OM2-01_env_vars.csv") %>% 
  select(any_of(names(mod_match_obs_split$baked_train)))
```





```{r}
library(parsnip)
library(workflows)
library(tidymodels)

crab_folds <- vfold_cv(model_data, v = 5)

spline_rec <- recipe(presence ~ ., data = model_data) %>% 
  step_ns(covars, deg_free = tune("df"))

gam_pars <- gen_additive_mod(adjust_deg_free = tune()) %>% 
  set_engine("mgcv") %>% 
  set_mode("regression") 

spline_grid <- expand.grid(df = 1:5)

gam_simple_wf <- workflow() %>% 
  add_variables(outcomes = presence, predictors = covars) %>% 
  add_model(gam_pars, formula = as.formula(gam_formula))

spline_res <- tune_grid(gam_simple_wf, crab_folds, grid = spline_grid)

%>% 
  fit(data = model_data) %>% 
  add_case_weights(weights) #%>%
  # extract_fit_engine()



gam_simple_wf %>% 
  workflow_map(resamples = crab_folds, grid = 10,
               metrics = metric_set(rmse), verbose = T)


gam_pred <- gam_simple_wf %>%
  predict(mod_match_obs_split$baked_test %>% 
            select(all_of(covars) | "presence"), type = "response") %>%
  as.vector() %>% 
  bind_cols(mod_match_obs_split$baked_test) %>% 
  rename("pred"="...1")

gam_pred %>% 
  roc_auc(presence, pred)#, case_weights = weights)


gam_sel <- gen_additive_mod(select_features = tune(), adjust_deg_free = tune()) %>% 
  set_engine("mgcv") %>% 
  set_mode("regression")

gam_sel_wf <- workflow() %>% 
  add_variables(outcomes = presence, predictors = covars) %>% 
  add_model(gam_pars, formula = as.formula(gam_formula))



gam_sel %>% 
  workflow
  tune_grid(resamples = crab_folds)

%>% 
  fit(data = model_data) %>% 
  add_case_weights(weights) %>% 
  extract_fit_engine()


gam_res <- 


show_best(gam_res, metric = "rmse")
```


